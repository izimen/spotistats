// Prisma Schema for MySpotifyStats
// Production-ready with token rotation, caching, and GDPR support

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id           String   @id @default(cuid())
  spotifyId    String   @unique
  email        String   @unique
  displayName  String?
  avatarUrl    String?
  country      String?
  product      String?

  // Token management with rotation support
  refreshToken String?  @db.Text // Encrypted, nullable for logout
  tokenExpiry  DateTime?
  tokenFamily  String?  // For refresh token rotation detection
  tokenVersion Int      @default(0) // Increment to invalidate all sessions

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  lastSyncAt   DateTime? // Last automatic cron sync timestamp

  // Relations
  streamingHistory  StreamingHistory[]
  imports           Import[]
  cachedTopItems    CachedTopItems[]
  aggregatedStats   AggregatedStats[]

  @@index([spotifyId])
  @@index([email])
  @@index([tokenFamily])
  @@index([lastSyncAt])
}

// Cached Spotify API responses (24h TTL)
model CachedTopItems {
  id        String   @id @default(cuid())
  userId    String
  type      String   // 'artists' | 'tracks' | 'albums'
  term      String   // 'short_term' | 'medium_term' | 'long_term'
  data      Json     // Spotify API response
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type, term])
  @@index([updatedAt])
  @@map("cached_top_items")
}

// Aggregated stats from imported history
model AggregatedStats {
  id          String   @id @default(cuid())
  userId      String
  trackUri    String   // spotify:track:xxxxx
  artistName  String
  trackName   String
  albumName   String?
  playCount   Int      @default(0)
  totalMsPlayed BigInt @default(0)
  firstPlayed DateTime?
  lastPlayed  DateTime?

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, trackUri])
  @@index([userId, playCount])
  @@index([userId, lastPlayed])
  @@map("aggregated_stats")
}

// Streaming history from Spotify API and extended data export
model StreamingHistory {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Track info
  trackId    String?  // Spotify track ID (for API-sourced data)
  trackName  String
  artistName String
  albumName  String?
  albumImage String?  // Album cover URL from Spotify
  spotifyUri String?

  // Listening data
  msPlayed   Int
  playedAt   DateTime

  // Source tracking: "API" (live collection) or "IMPORT" (GDPR export)
  source     String   @default("IMPORT")

  // Metadata
  platform   String?
  country    String?

  createdAt  DateTime @default(now())

  // Composite unique for deduplication
  @@unique([userId, trackName, artistName, playedAt])
  @@index([userId, playedAt])
  @@index([userId, artistName])
  @@index([userId, trackName])
  @@index([userId, source])
}

// Track import jobs
model Import {
  id          String       @id @default(cuid())
  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  fileName    String
  fileSize    Int
  status      ImportStatus @default(PENDING)

  totalTracks Int          @default(0)
  imported    Int          @default(0)
  skipped     Int          @default(0)
  duplicates  Int          @default(0)
  errors      Int          @default(0)

  errorMessage String?

  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime     @default(now())

  @@index([userId, status])
}

enum ImportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}
